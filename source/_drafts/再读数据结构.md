---
title: 再读数据结构
categories:
    数据结构
tags:
    编程
---
再次读《大话数据结构》这本书，回过头再跟着书系统的走一遍，记录巩固下基础。

#### 1. 数据结构绪论
数据结构是相互之间存在一种或多种特定关系的数据元素集合。

##### 1.1 基本概念与术语
* 数据： 描述客观事物的符号，是计算机中可以操作的对象。包括数值、字符、声音、图像、视频等等。
* 数据元素：组成数据的、有一定意义的基本单位。如人类中，数据元素是人，畜类中 牛、马、羊都是数据元素。
* 数据项：一个数据元素可以由若干个数据项组成。比如人这样数据元素，可以有眼、鼻、嘴、手等等这些数据项。**数据项是数据不可分割的最小单位**。在数据结构中，我们把数据项定义为最小单位，有助于更好的解决问题。
* 数据对象：是性质相同的数据元素的集合，是数据的子集。
* 数据结构：结构，简单的理解就是关系，即数据元素相互间关系形成的集合。

##### 1.2 逻辑结构与物理结构
**物理结构是面向计算机的，逻辑机构是面向问题的。** 其基本目标就是将数据及其逻辑关系存储到计算机的内存中。

###### 1.2.1 物理结构
数据在计算机内的存储形式，也称之为存储结构。

* **顺序存储** : 数据元素存放在地址连续的储存单元中。
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgmtzre5ouj20b402agm0.jpg)

* **链式存储**: 把数据元素存放在任意的存储单元里。数据元素的存储关系不能反映其逻辑关系，需要指针存放数据元素的地址。
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgmu3lswuwj209207v74z.jpg)

###### 1.2.2 逻辑结构
数据对象中数据元素之间的关系，逻辑结构分为以下四种：
* **集合结构**：集合结构中的数据元素同属一个集合，他们之间没有任何关系。
![](http://wx1.sinaimg.cn/mw690/929194b4gy1fgmu3m85mdj208b07uq3p.jpg)

* **线性结构**: 线性结构中的数据元素之间是一对一的关系。
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fgmu3ml3gfj207a05nq3a.jpg)

* **树形结构**: 树形结构中的数据元素是一对多的关系。
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fgmu3n1lylj208f05gjru.jpg)

* **图形结构**: 图形结构中的数据元素是多对多的关系。
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fgmu3nm4wjj207y06kt99.jpg)

另外，我们用示意图表示数据的逻辑结构时，要注意两点：
* 每个数据元素看做一个节点，用圆圈表示
* 元素间的逻辑关系用节点之间的连线表示，如果这个关系是有方向的，那么用带箭头连线表示

##### 1.3 抽象数据类型
###### 1.3.1 数据类型
数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

我的理解中，数据类型分一下：
* 计算机只认0、1数值类型
* 编程语言既要面向计算机、又要面向开发人员，则基于0、1包装了便于开发使用的类型：整形、长整形、字符型、字符串等等
* 开发人员基于开发语言为了满足业务需要，可能需要包装更多的数据类型

###### 1.3.2 抽象数据类型
对已有的数据类型进行抽象，就有了抽象数据类型。
**抽象数据类型（Abstract Data Type, ADT）: 是指一个数学模型及定义在该模型上的一组操作**，后面会用以下格式来表示抽象数据类型：
```
ADT 抽象数据类型名称
DATA
    数据元素之间逻辑关系的定义
Operation
    操作1
        初始条件
        操作结果描述
    操作2
        ...
    操作n
        ...
endADT
```

#### 2. 算法
##### 2.1 算法的定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

##### 2.2 算法的特性
五个基本特性：输入、输出、有穷性、确定性和可行性
##### 2.3 算法效率的度量方法
###### 2.3.1 事后统计方法
所谓“是骡子是马，拉出来溜溜”。比较容易想到的方法就是，通过对算法的数据测试，利用计算机的计时功能，来度量不同算法效率的高低，平常见到的`benchmark`就应该属于此类。

###### 2.3.2 事前统计方法
为了对算法的评判更加科学，计算机前辈们研究出一种叫做事前分析估算的方法。**事前分析估算方法：在计算机程序编制之前，依据统计方法对算法进行估算**
如以下有两种方法实现的指定范围内的求和实现：
第一种算法：
```c
int i, sum = 0, n = 100;        /* 执行 1 次 */
for (i = 1; i <= n; i++) {      /* 执行 n+1 次 */
    sum = sum + i;              /* 执行 n 次 */
}
printf("%d", sum);              /* 执行 1 次*/
```
第二种算法：
```c
int sum = 0, n = 100;           /* 执行 1 次*/
sum = (1 + n) * n/2;            /* 执行 1 次*/
printf("%d", sum);              /* 执行 1 次*/
```
显然第一种算法执行了 `2n + 3`次，第二种算法是`3`次; 事实上两个算法的首、尾语句都是一样的，我们把循环看作一个整体，那么两个算法其实就是`n`次与`1`次的差距。算法好坏显而易见。

##### 2.4 函数的渐进增长
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fgn1bv8smqj20fx046mye.jpg)
随着n的增加，算法A比算法B越来越好(执行的次数比B少)。于是我们可以得出结论，算法A总体上要算法B。 此时我们给出这样的定义，输入规模n，在没有限制的情况下，只要超过一个数值N，这个函数总是大于另一个函数，我们称函数是渐进增长的。
从中可以发现，随着n的增大，后面的`+3`、`+1`其实不影响最终算法变化，所以，**我们可以忽略这些加法常数**。
我们来看第二个例子，算法C是`4n + 8`，算法D是`2n² + 1`:
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgn1wgesojj20fq04pmyl.jpg)