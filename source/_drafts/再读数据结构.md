---
title: 再读数据结构
categories:
    数据结构
tags:
    编程
---
再次读《大话数据结构》这本书，回过头再跟着书系统的走一遍，记录巩固下基础。

#### 1. 数据结构绪论
数据结构是相互之间存在一种或多种特定关系的数据元素集合。

##### 1.1 基本概念与术语
* 数据： 描述客观事物的符号，是计算机中可以操作的对象。包括数值、字符、声音、图像、视频等等。
* 数据元素：组成数据的、有一定意义的基本单位。如人类中，数据元素是人，畜类中 牛、马、羊都是数据元素。
* 数据项：一个数据元素可以由若干个数据项组成。比如人这样数据元素，可以有眼、鼻、嘴、手等等这些数据项。**数据项是数据不可分割的最小单位**。在数据结构中，我们把数据项定义为最小单位，有助于更好的解决问题。
* 数据对象：是性质相同的数据元素的集合，是数据的子集。
* 数据结构：结构，简单的理解就是关系，即数据元素相互间关系形成的集合。

##### 1.2 逻辑结构与物理结构
**物理结构是面向计算机的，逻辑机构是面向问题的。** 其基本目标就是将数据及其逻辑关系存储到计算机的内存中。

###### 1.2.1 物理结构
数据在计算机内的存储形式，也称之为存储结构。

* **顺序存储** : 数据元素存放在地址连续的储存单元中。
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgmtzre5ouj20b402agm0.jpg)

* **链式存储**: 把数据元素存放在任意的存储单元里。数据元素的存储关系不能反映其逻辑关系，需要指针存放数据元素的地址。
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgmu3lswuwj209207v74z.jpg)

###### 1.2.2 逻辑结构
数据对象中数据元素之间的关系，逻辑结构分为以下四种：
* **集合结构**：集合结构中的数据元素同属一个集合，他们之间没有任何关系。
![](http://wx1.sinaimg.cn/mw690/929194b4gy1fgmu3m85mdj208b07uq3p.jpg)

* **线性结构**: 线性结构中的数据元素之间是一对一的关系。
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fgmu3ml3gfj207a05nq3a.jpg)

* **树形结构**: 树形结构中的数据元素是一对多的关系。
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fgmu3n1lylj208f05gjru.jpg)

* **图形结构**: 图形结构中的数据元素是多对多的关系。
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fgmu3nm4wjj207y06kt99.jpg)

另外，我们用示意图表示数据的逻辑结构时，要注意两点：
* 每个数据元素看做一个节点，用圆圈表示
* 元素间的逻辑关系用节点之间的连线表示，如果这个关系是有方向的，那么用带箭头连线表示

##### 1.3 抽象数据类型
###### 1.3.1 数据类型
数据类型是指一组性质相同的值的集合及定义在此集合上的一些操作的总称。

我的理解中，数据类型分一下：
* 计算机只认0、1数值类型
* 编程语言既要面向计算机、又要面向开发人员，则基于0、1包装了便于开发使用的类型：整形、长整形、字符型、字符串等等
* 开发人员基于开发语言为了满足业务需要，可能需要包装更多的数据类型

###### 1.3.2 抽象数据类型
对已有的数据类型进行抽象，就有了抽象数据类型。
**抽象数据类型（Abstract Data Type, ADT）: 是指一个数学模型及定义在该模型上的一组操作**，后面会用以下格式来表示抽象数据类型：
```
ADT 抽象数据类型名称
DATA
    数据元素之间逻辑关系的定义
Operation
    操作1
        初始条件
        操作结果描述
    操作2
        ...
    操作n
        ...
endADT
```

#### 2. 算法
##### 2.1 算法的定义
算法是解决特定问题求解步骤的描述，在计算机中表现为指令的有限序列，并且每条指令表示一个或多个操作。

##### 2.2 算法的特性
五个基本特性：输入、输出、有穷性、确定性和可行性
##### 2.3 算法效率的度量方法
###### 2.3.1 事后统计方法
所谓“是骡子是马，拉出来溜溜”。比较容易想到的方法就是，通过对算法的数据测试，利用计算机的计时功能，来度量不同算法效率的高低，平常见到的`benchmark`就应该属于此类。

###### 2.3.2 事前统计方法
为了对算法的评判更加科学，计算机前辈们研究出一种叫做事前分析估算的方法。**事前分析估算方法：在计算机程序编制之前，依据统计方法对算法进行估算**
如以下有两种方法实现的指定范围内的求和实现：
第一种算法：
```c
int i, sum = 0, n = 100;        /* 执行 1 次 */
for (i = 1; i <= n; i++) {      /* 执行 n+1 次 */
    sum = sum + i;              /* 执行 n 次 */
}
printf("%d", sum);              /* 执行 1 次*/
```
第二种算法：
```c
int sum = 0, n = 100;           /* 执行 1 次*/
sum = (1 + n) * n/2;            /* 执行 1 次*/
printf("%d", sum);              /* 执行 1 次*/
```
显然第一种算法执行了 `2n + 3`次，第二种算法是`3`次; 事实上两个算法的首、尾语句都是一样的，我们把循环看作一个整体，那么两个算法其实就是`n`次与`1`次的差距。算法好坏显而易见。

##### 2.4 函数的渐进增长
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fgn1bv8smqj20fx046mye.jpg)
随着n的增加，算法A比算法B越来越好(执行的次数比B少)。于是我们可以得出结论，算法A总体上要算法B。 此时我们给出这样的定义，输入规模n，在没有限制的情况下，只要超过一个数值N，这个函数总是大于另一个函数，我们称函数是渐进增长的。
从中可以发现，随着n的增大，后面的`+3`、`+1`其实不影响最终算法变化，所以，**我们可以忽略这些加法常数**。
我们来看第二个例子，算法C是`4n + 8`，算法D是`2n² + 1`:
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgn1wgesojj20fq04pmyl.jpg)
对比可以看出：**最高次项相乘的常数并不重要**

**判断一个算法的效率时，函数中的常数和其他次要项常常可以忽略，而更应该关注主项(最高阶项)**

##### 2.5 算法时间复杂度
在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随着n的变化情况并确定T(n)的数量。算法的时间复杂度，也就是算法的时间量度，记作：T(n)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，称作算法的渐进时间复杂度，简称为时间复杂度。
用大写的`O()`来体现算法时间复杂度的记法，称之为`大O记法`。比如`O(n)`、`O(1)`、`O(n²)`我们取的非官方名称分别为：线性阶、常数阶、平方阶。

##### 2.6 推导大O阶方法
推导大O阶：
1. 用常数 1 取代运行时间中所有的加法常数
2. 在修改后的运行次数函数中，只保留最高阶
3. 如果最高阶存在且不为1，则去除与这个项相乘的常数

##### 2.7 常见的时间复杂度
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fgqhynlnhuj208m05uq40.jpg)

#### 3 线性表
**线性表：零个或多个数据元素的有限序列**
特点：
* 序列，即元素间有顺序，若存在多个元素，则第一个元素无前驱，最后一个无后继，其他每个元素有且只有一个前驱和后继
* 有限

##### 3.1 线性表的抽象数据类型
```
    ADT 线性表(List)
    Data
        线性表的数据对象集合为{a₁,a₂...an}，每个元素的类型均为DataType。其中第一个元素除外，每一个元素有且只有一个直接前驱元素；最后一个元素除外，每一个元素有且只有一个直接后继元素。数据之间的关系是一对一。
    Operation
        InitList(*L): 初始化操作，建立一个空的线性表 L。
        ListEmpty(L): 若线性表为空，返回true，否则返回false。
        ClearList(*L): 将线性表清空。
        GetElem(L, i, *e): 将线性表L中的第i个元素返回给e。
        LocateElem(L, e): 在线性表L中查找与给定值e相等的元素，如果查找成功，返回该元素在表中的序号表示成功；否则，返回0表示失败。
        ListInsert(L*, i, e): 在线性表L中的第i个位置插入新元素e。
        ListDelete(L*, i, *e): 删除线性表L中第i个位置的元素，并用e返回其值。
        ListLength(L): 返回线性表L的元素个数。
    endADT
```
对于实际问题中涉及的更复杂的操作，完全可以基于以上的基本操作的组合来实现。

##### 3.2 线性表的顺序存储结构
下面看一下线性表的两种物理存储结构的第一种，顺序存储结构：**用一段连续的存储单元依次存储线性表的数据元素。**
顺序存储示意图：
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fgqj7mkv1hj20b901rt8p.jpg)
在内存中申请一段连续的地址，用来存储元素，那么这段地址长度意味着这个线性表的长度，实际使用个数代表元素实际长度。

###### 3.2.1 顺序结构的插入与删除
排队插入示意图：
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgqjl5xa81j20ce07n0uc.jpg)
插入算法思路：
* 检查插入位置
* 如果线性表长度大于等于数组长度，则抛出异常或动态增加容量(java ArrayList Arrays.copy 新开辟空间)
* **从最后元素向前遍历至第i个位置，分别将他们向后移动一位** ——(插入位置的后面的元素都需要站起来往后挪位置)
* 新元素插入位置i处
* 表长加1

删除示意图：
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fgqjl6i8dcj20eg08tmys.jpg)
删除算法思路：
* 检查删除位置
* 去除删除元素
* **从删除元素位置开始遍历到最后一个元素，分别将他们向前移动一个位置** 
* 表长减1

优点：
* 无需为表达元素间的逻辑关系而增加存储空间
* 可以快速地取表中任一位置的元素

缺点:
* 插入和删除操作需要移动大量元素
* 确定存储空间大小的问题(多了浪费，少了不够用，再申请影响性能)

##### 3.4 线性表的链式存储结构
线性表顺序结构存储最大的问题就是插入、删除时，其他位置的元素需要挪位置，链式存储结构的线性表能够解决此问题。链式存储结构不考虑相邻位置，那有空位就到哪里，只是让每个元素知道它的下一个元素的位置在哪里。
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgmu3lswuwj209207v74z.jpg)
* **节点（Node）分为两部分，数据域与指针域，数据域存储元素数据信息，指针域存储下一个节点地址。**
单链表中，用C语言描述如下：
```c
typedef struct Node {
    ElemType data;
    struct Node *next;
} Node;
typedef struct Node *LinkList; /*定义LinkList*/
```

###### 3.4.1 单链表的读取
在顺序存储结构的线性表中，我们根据元素位置取元素是非常容易的。但在单链表中，没有办法一开始就知道，必须得从头开始找。
获取链表第i个数据的算法思路：
* 声明一个节点p指向链表第一个节点，初始化j从1开始；
* 当 j<i 时，就遍历链表，让p的指针向后移动，不断指向下一节点，j累加1；
* 若到链表末尾p为空，则说明第i个元素不存在
* 否则查找成功，返回节点p的数据

单链表中没有定义表长，所以事先不知道要循环多少次，其核心思想就是**工作指针后移**

###### 3.4.2 单链表的插入与删除
插入示意图：
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fgqlowjswxj207n04t3yr.jpg)
我们可以看出来，新元素的插入，主要操作：新元素指针域指向后一个元素，更新前一个元素的指针域指向新元素。

删除示意图：
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fgqlowx93ej20ax04vaan.jpg)
同样可以看出来，元素的删除，主要操作：被删除元素的前一个元素更新指针域为被删除元素的指针域地址、销毁(返回)被删除元素

##### 3.5 静态链表
**用数组描述的链表叫做静态链表** ，数组元素由两个数据域组成：
* data 存放数据元素
* cur 游标，相当于单链表中的next指针，存放该元素的后继元素在数组中的下表

##### 3.6 循环链表
**将终端节点的指针指向头结点**，是整个单链表形成一个环，这种头尾相连的单链表称为单循环链表。

##### 3.7 双向链表
**在单链表的节点中增加一个指针，将其指向前驱节点**

##### 3.8 线性表总结
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgsrksslsdj20fd047jsl.jpg)

#### 4 栈与队列
**栈是限定仅在表尾进行插入和删除操作的线性表。**

**队列是只允许在一端进行插入操作、而在另一端进行删除操作的线性表**

##### 4.1 栈
手枪的弹匣就像是栈，放子弹进弹匣就是入栈，开枪打出子弹则是出栈。
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fgsrzqdlw9j20fh05g3zd.jpg)

###### 4.1.1 栈的抽象数据类型
```
ADT 栈(stack)
DATA
    同线性表。元素具有相同的类型，相邻元素有前驱、后继关系。
Operation
    InitStack(*s): 初始化操作，建立一个空栈S。
    DestoryStack(*S): 若栈存在，则销毁它。
    ClearStack(*S): 将栈清空。
    StackEmpty(*S): 若栈为空，返回true，否则返回false。
    GetTop(S, *e): 若栈存在且非空，用e返回S的栈顶元素。
    Push(*S, e): 若栈存在，则插入新元素e到S中，并成为栈顶元素。
    Pop(*S, *e): 删除栈S中的栈顶元素，并用e返回其值。
    StackLength(S): 返回栈S中的元素个数。
endADT
```
由于`栈`本身是一个线性表，所以之前提到过的线性表的顺序存储和链式存储，对于`栈`也同样适用。

###### 4.1.2 栈的顺序存储结构
看下栈的结构定义：
```c
typedef int SElementType; /* SElementType 类型根据实际情况而定，这里假设为int*/
typedef struct{
    SElementType data[MAXSIZE];
    int top;    /* 用于记录栈顶 */
}SqStack;
```
栈就像"阉割"版的线性表，强调的是栈顶的操作，高级语言中一般会提供`push`、`pop`、`peek`这样的方法。
这里用java简单的实现了顺序存储的栈[MyStack](https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/data/structure/MyStack.java)

###### 4.1.3 栈的链式存储结构
栈的链式存储结构，简称链栈。
栈的操作都是在栈顶上的，那链式存储的栈将栈顶放到链表的头部还是尾部呢？ 链表本身有头指针，栈也需要栈顶指针，所以合二为一，将栈顶放在单链表的头部。
这里就不过多介绍链式存储的栈了，其对比顺序存储栈的特点体现在链式存储上。

##### 4.2 队列
队列就像排队买票，强调的是新来的人排在队尾，买票的人在队头，强调先进先出。

###### 4.2.1 队列的抽象数据类型
```
ADT 队列(Queue)
DATA
    同线性表。元素具有相同的类型，相邻元素具有前驱、后继关系。
Operation
    InitQueue(*Q): 初始化队列Q。
    DestoryQueue(*Q): 销毁队列Q。
    ClearQueue(*Q): 清空队列Q。
    QueueEmpty(Q): 若队列为空，则返回false，否则返回true。
    GetHead(Q, *e): 若队列Q非空，则用e返回队列Q的队头元素。
    EnQueue(*Q, e): 入队列，插入新的元素e至队列Q中并成为队尾。
    DeQueue(*Q, e): 出队列，删除队列Q中的队头元素，并用e返回。
    QueueLength(Q): 返回队列Q的元素个数。
endADT
```

###### 4.2.2 循环队列
同样，队列也是一种特殊的线性表，也有顺序存储和链式存储。

队列顺序存储的问题：与顺序存储的线性表不同，如果单纯用数组首个元素作为队列头，最后一个元素作为队列尾，那么元素出队列，数组内的元素就需要往前移动，很明显队列就是专门用来处理入队、出队的数据类型，不像线性表的数据是单调读多、单调写多。所以就有了循环队列来解决这个问题。
头尾相连顺序存储结构的队列。
使用`front`表示头，`rear`表示尾。
![](http://wx2.sinaimg.cn/mw690/929194b4gy1fgv54pvgd7j209z040glq.jpg)
这样有一个问题，空队列时 `front == rear`、队列满时也是如此，那怎么区分呢？
有两种方法：
* 另外定义一个flag，用来记录队列为空或已满
* 队列留空一格，也就是说队列满时，数组中还有一个空闲单元

用java实现的循环队列：[MyArrayQueue.java](https://github.com/elegance/dev-demo/blob/master/java-demo/src/main/java/org/orh/data/structure/MyArrayQueue.java)