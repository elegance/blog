---
title: 前端与后端的通信
tags:
categories:
    - HTTP
    - 通信
---
理解了，不用了又淡忘了，渐渐模糊混淆，感觉耗费大把的经历。

## 前端与后端的通信方式
通信，总的来说就是网络通信，所以从`Chrome`的控制台的`Network`可以看到前端与后端的通信，如下图：
![](http://wx3.sinaimg.cn/mw690/929194b4gy1fhfr4aok4rj20au00udfn.jpg)

我暂时打算记录一下开发经常碰到的问题。

## HTTP 通信
这里的介绍不会一应俱全，如果有需要你可以去参考一些权威指南。跟着自己的思考，带着一些问题来记录。

#### HTTP 是无状态
就像你在围墙外面，我在围墙里面，我们通过扔纸条的方式来通信，我不知道你是谁。
无状态带来的问题很明显，如果有两个人站在墙外，我不知道你是谁，那我们就不能聊一些私密的话题了。
在互联网，乃至整个现实世界，要绝对的确认一个人的身份是不可能的，网络上的信息可以被截取、模仿，现实世界有人工智能，就像那句“我不是李开复,我是人工智能。”

#### HTTP 请求与响应
请求与响应就类似传递的信件，一部分是正文，一部分是必要的附加信息比如地址、身份等等。所以HTTP的“信件”分为了head、body部分。像一封信一样，虽然分为head、body但是他们是在一个报文内的。

HTTP/1.1 head 是文本(ASCII编码), body 可以是文本，也可以是二进制。
HTTP/2 则是一个彻底的二进制协议，头、数据体都是二进制，并且统称为“帧”（frame）：头信息帧、数据帧，因为帧可以方便的扩展，解析更为方便，HTTP/2已经定义了近十种帧。

来看下一个完整的请求报文：
```
POST https://www.tzb360.com/tzb-api/api/public/login HTTP/1.1
Host: www.tzb360.com
Connection: keep-alive
Content-Length: 47
Origin: https://www.tzb360.com
User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/59.0.3071.86 Safari/537.36
Content-Type: application/x-www-form-urlencoded; charset=UTF-8
Accept: */*
X-Requested-With: XMLHttpRequest
Referer: https://www.tzb360.com/html/common/login.html
Accept-Encoding: gzip, deflate, br
Accept-Language: zh-CN,zh;q=0.8
Cookie: userId=test01; io=j8nS4_Ph2Jaq1aSWAFX4

loginName=cqtl123&password=tk110234&imgVefCode=
```
可以看出：
* **14行前的是请求头，即head；14行之后的是请求体，即body**
* **14行本身是分隔，其内容是`空行`，即CR+LF（Carriage Return 回车， Line Feed 换行）**
    * 打字机，在纸张上打印字时，分为纵向移动、横向移动。纸张的一行打满后，横向位置回到起点，即携带纸张的车子回到起点即回车；纵方向上向下移动一行，即换行。
    * unix 结尾只有换行“\n”，window下是“\r\n”。现象就是：win下的文件在unix下会出现“^M”符号；unix下的文件到win下会连接成一行。
    * [关于回车与换行的参考](http://www.ruanyifeng.com/blog/2006/04/post_213.html?bsh_bid=705296311)
* **请求地址、cookie、请求内容长度等等都是在请求头内的**

响应头报文：
```
HTTP/1.1 200 OK
Server: nginx/1.9.9
Date: Tue, 11 Jul 2017 06:02:51 GMT
Content-Type: application/json
Content-Length: 928
Connection: keep-alive
Set-Cookie: TZB_SESSIONID=5788439a2c524880a5f79c6b81e97fcf; Path=/; HttpOnly

{"code":"0000","data":{},"msg":"操作成功"}
```
同样可以看出，也是适用`\r\n`作为头、体的分隔符的。

#### 发起请求与后台接收请求
编码方面这前端请求主要用：`XMLHttpRequest/fetch`来实现，后台用`Spring MVC`来实现。
这里我会用`Spring MVC的Controller`中的一些相关信息来解释。

`@GetMapping`、`@PostMapping`、`@RequestMapping(method, params="action=ACT", parmas="!action", consumes = MediaType.APPLICATION_FORM_URLENCODED_VALUE, produces = MediaType.TEXT_HTML_VALUE)`
`@PathVariable`、
`@RequestBody`、`@ResponseBody`

#### HTTP 协议版本
这里再简单的记录下HTTP的几个版本的区别: （需要明白协议的实现要客户端、服务端共同完成，即新的浏览器、新的Web服务（Nginx/Apache/IIs等））
* HTTP/1.0 每个TCP只能发送一个请求。发完数据就关闭
* HTTP/1.1 (当今主流) 
    * 持久连接`Connection: keep-alive`，TCP默认不关闭，可以供多个请求复用，不用手动声明。连接没有活动，客户端就可以主动关闭连接了。规范的请求是，客户端发送最后一个请求时发送`Connection: close`，明确要求服务器关闭TCP连接。一般对于同一个域名，浏览器允许建立6个持久连接。
    * 管道机制（pipelining），同一个TCP中可发送多个请求
    * Content-Length字段，一个TCP连接中有多个请求或响应，用长度区分数据边界
    * 分块传输编码，`Content-length`的前提是在传输之前就得知道要传输的数据长度，对于一些耗时久、数据块大的操作来说，意味长时等待，这不太合理。更好的办法是产生一块数据，发送一块数据。使用`Transfer-Encoding: chunked`来表明数据是数量未定的数据块组成，每个非空数据块之前，会有一个16进制的数值，表示这个块的长度，最后一个大小为0的块，表示本轮数据传输完毕。
* HTTP/2 
    * 二进制协议
    * 多工，复用的TCP不要求请求、应答顺序一一对应，避免了“队头阻塞”，这样能达到双向、实时，即多工（Multiplexing）
    * 数据流，一个连接内的数据包，可能归属不同的请求或响应，每个请求或响应的所有数据包，称之为一个数据流（stream）。每个stream都有一个编号，客户端请求的stream编号为奇数，服务端发起的stream为偶数。
    * 头信息压缩，无状态导致很多字段都是重复的，比如Cookie和UserAgent等。因此引入了头信息压缩机制（header compression），一方面压缩传输，一方面server与client共同维护一张头表，所有字段存入这个表，生成一个索引号，只发索引号来减少传输。
    * 服务器推送，允许服务器未经请求，主动向客户端发送资源。以前是请求-返回网页，解析网页源码，请求网页依赖的静态资源；而现在可以主动把这些依赖的静态资源随着网页一起发给客户端。

#### 安全
从`无状态` ----> `身份识别` -----> `各种识别的方式的安全问题`
`cookie在客户端被盗` - 客户端 cookie http-only(各种方式只是尽量避免不被盗取)、服务端 cookie client ip白名单(不严谨) 
`传输被窥视` -- https
