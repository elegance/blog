---
title: 大话设计模式-简要记录
tags:
---

#### 1. 计算器-简单工厂
Skills:
* 封装、继承、多态 （继承-重写-父指子）
* 简单工厂实例化生产对象

使用任意一种面向对象的语言实现一个计算器控制台程序，要求输入两个数和运算符号，得到结果。 [Calc](https://github.com/elegance/dev-demo/blob/master/java-demo/pattern/ch01/Calc.java)

1. 初版，一个Main方法实现
    * 不规范的变量命名
    * `if`无用功
    * 除数为0异常未处理
    * 无面向对象

2. 为何要面向对象？
曹操 => `喝酒当歌，人生真爽`  一臣速命工匠印刷，以便流传天下。
一看,喝和唱太俗，不妥 => `对酒当歌，人生真爽` ,工匠连夜刻板重来。
再细细一品，人生真爽太过直接 => `对酒当歌，人生几何` 工匠晕倒。

#### 2. 商品促销-策略模式
```
// 需求递进：
// 最初简单要求：收银 = ∑(商品价格 * 数量)
// ...

// 开业酬宾八折：收银 = ∑(商品价格 * 数量)
// ... totalPrice * 0.8

// 恢复之前规则：收银 = ∑(商品价格 * 数量)
// ... 不能再改回代码吧，于是决定把打折不打折的决定权交给 用户，下拉选择：[不打折， 打八折，打x折]
....

// 促销规则：满200减50、满300减100
// 根据之前经验，考虑支持： 满xx减xx、打x折
```

工厂模式实现的促销：[SuperMarket](https://github.com/elegance/dev-demo/blob/master/java-demo/pattern/ch02/SuperMarket.java) ，外部依赖工厂类、以及工厂类方法返回的实例

策略+工厂模式实现的促销：[SuperMarketStrategy](https://github.com/elegance/dev-demo/blob/master/java-demo/pattern/ch02/SuperMarketStrategy.java)，外部只依赖 CashContext

策略封装了变化。

#### 3. 拍摄UFO (反例：车站换票购票一体机、以前的JSP等)—— 单一职责原则
就一个类而言，应该仅有一个引起它变化的原因。 

一个类承担的职责过多，等于职责耦合，一个职责的变化可能削弱或抑制这个类的其他职责能力。 要跳出来加以区分，比如拎出来核心逻辑、界面逻辑等

#### 4. 开发-封闭原则
**OCP(Open Close Principle): 对于扩展是开放的，对于更改是封闭的** 面对变动多扩展，少修改。

#### 5. 依赖倒转原则
面向对象：可维护、可复用、可扩展、灵活性好

CPU、内存、硬盘：职责单一

硬盘不够，可添加移动硬盘；内存不够，可添加内存条： 开闭原则

依赖倒转原则：抽象不应该依赖细节，细节应该依赖抽象；即要针对接口编程，不要对实现编程。谁也不依赖谁，除了约定的接口。

* 高层模块不应该依赖低层模块，两个都应该依赖抽象
* 抽象不应该依赖细节。细节应该依赖抽象

里氏代换原则（LSP）：子类必须能够替换掉他们的父类型。

#### 6. 装饰模式
装饰模式(Decorator): 动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活

#### State 状态模式
适用解决问题：多路if 判断，状态相互切换: [StatePattern](https://github.com/elegance/dev-demo/blob/master/java-demo/pattern/StatePattern.java)