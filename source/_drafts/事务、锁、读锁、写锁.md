---
title: 事务、锁、读锁、写锁
draft: true
date: 2017-02-23 12:15:25
tags:
---

```
参考自：[阿里沈询：分布式事务原理与实践](http://jm.taobao.org/2017/02/09/20170209/)
第一期《阿里沈询：分布式事务原理与实践》：https://yq.aliyun.com/articles/69211
第二期《阿里沈询：分布式事务原理与实践（二）》：https://yq.aliyun.com/edu/lesson/play/551
第三期《阿里沈询：分布式事务原理与实践》：http://yq.aliyun.com/webinar/play/185
```

### 处理事务的常见方法
1. 排队法
2. 排他锁
3. 读写锁 （读多写少的资源，其核心是多次读的操作中，同时允许多个读者来共享资源，提高并发性）
4. MVCC(Multi-Version Concurrency Control) 多版本并发控制


### 一些锁的详细介绍

排它锁：当试图修改数据时，事务会为所修改的数据请求排它锁，一旦授予，事务将持有锁直至事务完成。

共享锁：当时图读取数据时，事务会为锁读取的数据请求共享锁，读取一旦完成就立即释放资源上的共享锁，之所以称之为共享锁，应因为多个事务可以共同持有同一资源的共享锁。

#### 事务间锁相互制约关系：
1. 如果数据正在由一个**事务**修改，那么其他**事务**既不能修改该数据，也不能读取（至少默认不能）
2. 如果数据正在由一个**事务**读取，那么其他**事务**就不能修改该数据（至少默认不能）

事务修改数据(java断点尝试，分别使用无事务读取、启动事务读取尝试)：
```
tx1.begin();
update t1 set amount = amount - 1 where id = 1; 
//断点此处，此时 其他事务不能修改、读取id为1的记录

update t1 set amount = amount + 1 where id = 2; 
tx1.commit();
```

事务读取数据(java断点尝试，分别使用无事务修改、启动事务修改尝试)：
```
tx1.begin();
select amount from t1 where id = 1;
//断点此处，此时 其他事务不能修改id为1的记录

tx1.commit();
```

##### MVCC
本质是Copy On Write，也就是每次写都是以重新开始一个新的版本的方式写入数据，因此，数据库中也就包含了之前的所有版本。在数据读的过程中，先申请一个版本号，如果该版本号小于正在写入的版本号，则数据一定可以查询到，无需等到新版本完全写完即可返回查询结果。这种方式可以在读读不阻塞的前提下，实现读写/写读不阻塞，尽可能保证所有的读操作并行，而写操作串行。