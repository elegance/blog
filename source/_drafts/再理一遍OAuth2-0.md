---
title: 再理一遍OAuth2.0
tags:
---
OAuth在我印象中已经啃过几次了。大多数时候，好记性还是不如烂笔头，对自己的记忆力太过自信了，当时理解了，觉的妙，但是现在只记得一个妙字了，至于其它的已经忘的差不多了...

所以最好趁自己刚理解的那一刻，赶紧的尽量用自己组织的语言记录下来。

## 概念

首先，想到`OAuth 2.0`，脑海中先弹出**三方交互**的概念，三方即如下：
* **资源提供者**
* **用户(资源拥有者)**
* **获取资源者**

在来挨个解释下，**资源提供者**，好比新浪微博提供了发微博、获取微博列表，百度网盘提供了存储文件、访问文件列表的服务，其中新浪微博、百度网盘都是资源的提供者。**用户**就是资源拥有者，具体的某条微博、网盘里的某个照片都是具体用户的，没有得到用户允许，资源提供者不可供其他应用使用。**获取资源者** 就是一些非资源提供者的应用想要访问这些资源，比如一款冲印照片的应用需要访问你网盘里的照片。

`资源提供者`、`获取资源者`、`用户(资源拥有者)`，为了引用方便，我们先将分别简称其为：`B1`、`B2`、`C`。站在`B1`的角度来说，它定义了OAuth服务，交互细节都有它来设计，整个流程都需要依赖它，其一般是拥有众多用户的高可用服务。对于`B2`来说，它“觊觎”`B1`庞大的用户群以及用户资源(为用户省心，避免再注册于在上传资源)，它的最终目的是通过`Access Token`拿到想要的资源。对于`C`来说，它其实既是`B1`的用户，也是`B2`的用户，`C`在整个过程中只需要选中同意还是不同意。

搞清楚了这些概念后，如果你要做应用，最好确定下你是要做**提供者的应用** 还是**获取者的应用**，前者相当于是要在基于现有服务，整理好资源提供一整套`OAuth 2.0`的Server，后者作为一个`OAuth 2.0`的Client相对较为简单。

## 软件架构概念
有了以上的概念我们就能从宏观上来理解为什么会有OAht2.0的存在。如果要从软件上来实现它，基于以上三者，我们还需要细分一下，如下：
* 资源提供者
    * **HTTP service**: HTTP服务提供商
    * **Resource Server**: 资源服务器，可能你需要整理归类下现有的资源，有的资源可能不需要列入资源服务器。比如[新浪微博的接口分组](http://open.weibo.com/apps/4307576/privilege)
    * **Authorization server**: 认证服务，提供资源的授权服务
* 用户(资源拥有者)
    * **Resource Owner**: 资源拥拥有者，用户
    * **User Agent**: 用户代理，这个就代表着用户，一般就是浏览器、操作界面。
* 获取资源者
    * **Third-part application**： 第三方应用程序

## 应用
* 作为第三方应用，避免注册环节，用微博、微信、QQ等登录/注册
* 作为三方应用，访问用户的资源，比如分享微博，打印网盘照片等

## 运行流程
`OAuth 2.0`的运行流程如下：(referrence from [RFC-6749](https://www.rfc-editor.org/rfc/rfc6749.txt))
```
     +--------+                               +---------------+
     |        |--(A)- Authorization Request ->|   Resource    |
     |        |                               |     Owner     |
     |        |<-(B)-- Authorization Grant ---|               
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(C)-- Authorization Grant -->| Authorization |
     | Client |                               |     Server    |
     |        |<-(D)----- Access Token -------|               |
     |        |                               +---------------+
     |        |
     |        |                               +---------------+
     |        |--(E)----- Access Token ------>|    Resource   
     |        |                               |     Server    |
     |        |<-(F)--- Protected Resource ---|               |
     +--------+                               +---------------+
```
步骤如下：
```
(A) 用户打开客户端后，客户端要求用户授权
(B) 用户同意给予客户端授权
(C) 客户端使用上一步获得的授权，向认证服务器申请令牌。
(D) 认证服务器对客户端进行认证后，确认无误，同意发放令牌
(E) 客户端使用令牌，向资源服务器申请获取资源
(F) 资源服务器确认令牌无误，同意向客户端开放资源
```
简单的来分析下，上面的流程是以请求为载体流转的，最终拿到Access token需要经过几个步骤，但是拿到的Access Token在失效前一直可以重复使用，也就是后面对资源的请求都是请求-应答这种方式。得到Access Token前花费两次“请求-响应”，一次是询问用户是否授权，另外一次是根据授权码请求得到Access Token。这一点与我们平时的普通web应用不同，平时web的认证只需要一次登录“请求-响应”，一般请求携带着用户名、密码，响应头里设置客户端sessionid至cookie。为什么前者需要两次，而后者只需要一次呢？因为后者服务端只需要验证用户名密码是否正确，而前者则需要转个弯，三方应用先向用户申请，申请同意过后再向资源提供的应用申请。

## 授权模式
前面讲到三方应用要向用户申请授权，这个过程要怎么做才合适呢？很显然这个**授权的界面**不能由第三来做，不然就没一点意义了，这个授权的界面都是资源提供方来做的，一般在界面还会提示一些文字让用户确认该界面是资源官方提供的，比如新浪微博:
![](http://wx4.sinaimg.cn/mw690/929194b4gy1fh6smtxhlsj20h00980t5.jpg)
这个提醒大多数普通用户是忽略的，因为现在也很少有黑客用这种方式用来盗取微博的密码了，不过这种方式在仿银行的网站上存在很多。

客户端必须得到用户的授权（authorization grant），才能获取令牌（Access Token），OAuth2.0定义了四种授权方式。
* 授权码模式 （authorization code）
* 简化模式 （implicit）
* 密码模式 （resource owner password credentials）
* 客户端模式 （client credentials）

## 授权码模式
授权码模式（authorization code）是功能最完整、流程最严密的授权模式。它的特点是通过客户端的后台服务器，与“服务提供商”的认证服务器进行互动。
```
     +----------+
     | Resource |
     |   Owner  |
     |          |
     +----------+
          ^
          |
         (B)
     +----|-----+          Client Identifier      +---------------+
     |         -+----(A)-- & Redirection URI ---->|               |
     |  User-   |                                 | Authorization |
     |  Agent  -+----(B)-- User authenticates --->|     Server    |
     |          |                                 |               |
     |         -+----(C)-- Authorization Code ---<|               |
     +-|----|---+                                 +---------------+
       |    |                                         ^      v
      (A)  (C)                                        |      |
       |    |                                         |      |
       ^    v                                         |      |
     +---------+                                      |      |
     |         |>---(D)-- Authorization Code ---------'      |
     |  Client |          & Redirection URI                  |
     |         |                                             |
     |         |<---(E)----- Access Token -------------------'
     +---------+       (w/ Optional Refresh Token)
```

## 实战
[OAuth2集成——《跟我学Shiro》](http://jinnianshilongnian.iteye.com/blog/2038646)

## 关于安全
从以上的实现机制，可以看出最终是为了得到`token`。其实这个`token`与平时web会话客户端的那个 `sessionid`的本质意义是一样的，都是用户的身份标识。
为了`sessionid`的安全我们一般会做两点，后台设置的response cookie是`httpOnly`的，也就是js不可读取保证客户端安全，另外就是使用`https`保证传输通道的安全。按照这个思路我们可以类比下这个`token`该怎么在安全方面有所保障。

---
## 参考
* [简述 OAuth 2.0 的运作流程](http://www.barretlee.com/blog/2016/01/10/oauth2-introduce/)
* [Oauth的access token 安全么?](https://www.zhihu.com/question/20274730)
* [理解OAuth 2.0](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)