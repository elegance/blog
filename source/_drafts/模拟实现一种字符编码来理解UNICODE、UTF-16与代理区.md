---
title: 模拟实现一种字符编码来理解UNICODE、UTF-16与代理区
tags:
---
　　其实这里主要是来理解代理区，要讲代理区离不开Unicode、UTF-16，顺带再加深理解下Unicode中的码点，UTF-16的变长编码实。

　　固长的编码实现还相对算好理解，即按照固定的长度来进行编码、解码，牺牲一些空间来降低复杂度，`UTF-32`固定按32bit位即4个字节来实现编码。0-9、a-z等使用`ASCII`编码占1个字节的字符，使用`UTF-32`会固定占4个字节。即1个1G的`ASCII`编码的文件，用`UTF-32`来编码的话会占4G。
* 固长编码特点：复杂度低，其存在的问题是**定多长，定少了不够用，定多了浪费空间**
* **定长编码特点：具有一定复杂度，其核心解决的问题是**如何区分不同的变长字节**

下面我们就一起来理解下**UTF-16**是怎么区分不同的变长字节的。


编码需求：**用`0-F`16个16进制数字来表示26个字符`A-Z`**

先定义1个我们自己的Unicode，命名为`my-Unicode`

#### my-Unicode
像`Unicode`样这里只是规定了码点与字符的对应关系，并没有如何存储

编号    |   码点    |   字符
--------|-----------|-------
1       |   0       |    A
2       |   1       |    B
3       |   2       |    C
4       |   3       |    D
5       |   4       |    E
6       |   5       |    F
7       |   6       |    G
8       |   7       |    H
9       |   8       |    I
10      |   9       |    J
11      |   A       |    K
12      |   B       |    L
13      |   C       |    M
14      |   D       |    N
15      |   E       |    O
16      |   F       |    P
17      |   10      |    Q
18      |   11      |    R
19      |   12      |    S
20      |   13      |    T
21      |   14      |    U
22      |   15      |    V
23      |   16      |    W
24      |   17      |    X
25      |   18      |    Y
26      |   19      |    Z


可以看出我们这里:
* 码点格式是：`U+[X]X`，X代表16进制数字, 可以是1-2位
* 位码点范围是: `U+0~U+19`

#### my-utf-16
同上，这里类比UTF-16，不是以16bit位作为编码单元。

同`UTF-16`使用**代理区**的方式来实现。

假如A、B、C、D 是我们的常用字符，就想象这是单选题的场景，那么我们的`BMP`基础面如下

code    |   char
--------|------
    1   |   A
    2   |   B
    3   |   C
    4   |   D
    5   |   
    6   |   
    7   |   
    8   |   
    9   |   
    A   |
    B   |
    C   |
    D   |   
    E   |   
    F   |   .

* `5-E`行为空白，即代理区，类比[鸟瞰BMP字符集](http://unifoundry.com/pub/unifont-7.0.03/unifont-7.0.03.bmp)中的`D8-DF`行。

代理图:

高低位 | A |  B |  C |  D |  E 
-------|---|----|----|----|----
    5  | E |  F |  G |  H |  I 
    6  | J |  K |  L |  M |  N
    7  | O |  P |  Q |  R |  S
    8  | T |  U |  V |  W |  X   
    9  | Y |  Z |    |    |  

其中`5-9`为高代理区，`A-E`低代理区。一个高代理区加一个低代理区组合成一对即是**代理对**，如上面的`5A`，必须是这种先高后低的顺序，如果出现两个高，两个低，或者先低后高，都是非法的。

那我们`my-unicode`到`my-utf-16`如何转换？
分成两部分：
1. BMP中有的直接转换，如上面BMP中的A、B、C、D、.
2. 代理区中的转换，这个其实就类似增补面.
    1. 得到代理的绝对位置：码点位置减去前面的未代理位置，即`起始点位置-1`(5-1) ，绝对位置就像是横向铺开不换行.
    2. 取需折行次数和余数，即绝对位置除以一行个数，一行的个数其实就是这里的低位代理区个数`5`个。
    3. 码点：高代理区起点 + 折行数，低代理区起点 + 余数

比如码点 `8` (I) 对应的代理对:
```
8 - 4 = 4 , 4/5 = 0...4  => 5+0, A + 4 = 5E
```
再比如码点`12`(S)（需要注意这里是16进制的12）:
```
0x12 - 4 = 14, 14/5 = 2...4 => 5+2, A+4 = 7E
```
再比如码点`15`(V):
```
0x15 - 4 = 17, 17/5 = 3...2 => 5+3, A+2 = 8C
```
假如我们分别收到字节流(类比，非真正字节流)`1`，`5E`，碰到处于非代理区code `1`则读取1个，直接根据`my-unicode`翻译成A，碰到代理区字符，则通过代理表算出`my-unicode`码点，根据码点取得字符`I`，所以这个流的内容就是`AI`

##### my-utf-16 小结
1. 类比长度
    * 我们的`my-utf-16`: 以1个code作为编码单元，常用字符`A/B/C/D`只需要1个编码单元即可；罕见字符`E-Z`需要两个编码单元a；--(我们这里的场景可以理解为是**单择题场景，一般答案是A-D四个选项，特殊的有A-D之外的选项**)
    * `utf-16`：以2字节作为编码单元，常用字使用1个单元占2字节；罕见生僻字使用两个单元占4字节
2. 类比代理区
    * `my-utf-16` 使用了`5-9`为高位代理区，`A-E`为低位代理区；高低各5位，总共可代理数：`5*5=25 个`
    * `utf-16` 使用了`D800–DBFF`为高位代理区,`DC00–DFFF`为低位代理区；高低各1024位，总共代理数：`1024 * 1024 = 2^10 * 2^10 = 2^4 * 2^16 = 16 * 65536`代理了16个增补面
3. 字节序问题
    * 很遗憾因为我们这里的`my-unicode`本身没有